import http.client
import msgpack
import time                                                                                                                                   
from util import *

# Interface of Metasploit.
class Msgrpc:
    def __init__(self, option=[]):
        self.host = option.get('host') or "127.0.0.1"
        self.port = option.get('port') or 55552
        self.uri = option.get('uri') or "/api/"
        self.ssl = option.get('ssl') or False
        self.authenticated = False
        self.token = False
        self.user = ""
        self.password = ""
        self.headers = {"Content-type": "binary/message-pack"}
        if self.ssl:
            self.client = http.client.HTTPSConnection(self.host, self.port)
        else:
            self.client = http.client.HTTPConnection(self.host, self.port)

    # Call RPC API.
    def call(self, meth, option):
        if meth != "auth.login":
            if not self.authenticated:
                print('MsfRPC: Not Authenticated')
                exit(1)

        if meth != "auth.login":
            option.insert(0, self.token)

        option.insert(0, meth)
        params = msgpack.packb(option)

        try:
            self.client.request("POST", self.uri, params, self.headers)
            resp = self.client.getresponse()
        except: # remote disconnect
            # re-connect 
            print(RED+"Remote disconnected... wait 3 seconds and try to reconnect"+ENDC)
            time.sleep(3)
            try:
                if self.ssl:
                    self.client = http.client.HTTPSConnection(self.host, self.port)
                else:
                    self.client = http.client.HTTPConnection(self.host, self.port)
            except:
                writeError("Msf RPC Connect Error!")
                exit(1)

            else:
                raise Exception('Remote disconnect')
            
        return msgpack.unpackb(resp.read())

    # Log in to RPC Server.
    def login(self, user, password):
        try:
            ret = self.call('auth.login', [user, password])
        except:
            errMsg = 'MsfRPC Authentication Failed or Remote Connect Refused'
            print(RED+errMsg+ENDC)
            writeError(errMsg)
            exit(1)
        else:    
            if ret.get(b'result') == b'success':
                self.authenticated = True
                self.token = ret.get(b'token')
                return True
            else:
                errMsg = 'MsfRPC Authentication Failed or Remote Connect Refused'
                writeError(errMsg)
                exit(1)

    # Send Metasploit command.
    def send_command(self, console_id, command, visualization, sleep=0.1):
        _ = self.call('console.write', [console_id, command])
        time.sleep(sleep)
        ret = self.call('console.read', [console_id])
        if visualization:
            try:
                print(ret.get(b'data').decode('utf-8'))
            except Exception as e:
                print("type:{0}".format(type(e)))
                print("args:{0}".format(e.args))
                print("{0}".format(e))
                print('send_command is exception')
        return ret

    # Get all modules.
    def get_module_list(self, module_type):
        ret = {}
        if module_type == 'exploit':
            ret = self.call('module.exploits', [])
        elif module_type == 'auxiliary':
            ret = self.call('module.auxiliary', [])
        elif module_type == 'post':
            ret = self.call('module.post', [])
        elif module_type == 'payload':
            ret = self.call('module.payloads', [])
        elif module_type == 'encoder':
            ret = self.call('module.encoders', [])
        elif module_type == 'nop':
            ret = self.call('module.nops', [])
        byte_list = ret[b'modules']
        string_list = []
        for module in byte_list:
            string_list.append(module.decode('utf-8'))
        return string_list

    # Get module detail information.
    def get_module_info(self, module_type, module_name):
        return self.call('module.info', [module_type, module_name])

    # Get payload that compatible module.
    def get_compatible_payload_list(self, module_name):
        ret = self.call('module.compatible_payloads', [module_name])
        byte_list = ret[b'payloads']
        string_list = []
        for module in byte_list:
            string_list.append(module.decode('utf-8'))
        return string_list

    # Get payload that compatible target.
    def get_target_compatible_payload_list(self, module_name, target_num):
        try:
            ret = self.call('module.target_compatible_payloads', [module_name, target_num])
            byte_list = ret[b'payloads']
        except:
            err_class = ret[b'error_class'].decode('utf-8')
            err_msg = ret[b'error_message'].decode('utf-8')
            errMsg = err_class+": "+err_msg+" when get payload lsit from "+module_name
            writeError(errMsg)
            return None
        string_list = []
        for module in byte_list:
            string_list.append(module.decode('utf-8'))
        return string_list

    # Get module options.
    def get_module_options(self, module_type, module_name):
        return self.call('module.options', [module_type, module_name])

    # Execute module.
    def execute_module(self, module_type, module_name, options):
        ret = self.call('module.execute', [module_type, module_name, options])
        try:
            job_id = ret[b'job_id']
            uuid = ret[b'uuid'].decode('utf-8')
        except:
            err = ret[b'error_message'].decode('utf-8')
            errMsg = module_name + "excecution error! "+err
            writeError(errMsg)
            # msf session abort, try to re login 
            if err == "Invalid Authentication Token":
                raise       
            return None,None
        return job_id, uuid

    # Get job list.
    def get_job_list(self):
        jobs = self.call('job.list', [])
        byte_list = jobs.keys()
        job_list = []
        for job_id in byte_list:
            if job_id.decode('utf-8').isnumeric():
                job_list.append(int(job_id.decode('utf-8')))
        return job_list

    # Get job detail information.
    def get_job_info(self, job_id):
        return self.call('job.info', [job_id])

    # Stop job.
    def stop_job(self, job_id):
        return self.call('job.stop', [job_id])

    # Get session list.
    def get_session_list(self):
        try:
            ret = self.call('session.list',[])
        except:
            raise
            return
        return self.call('session.list', [])

    # Stop shell session.
    def stop_session(self, session_id):
        _ = self.call('session.stop', [str(session_id)])

    # Stop meterpreter session.
    def stop_meterpreter_session_kill(self, session_id):
        _ = self.call('session.meterpreter_session_kill', [str(session_id)])

    # Log out from RPC Server.
    def logout(self):
        ret = self.call('auth.logout', [self.token])
        if ret.get(b'result') == b'success':
            self.authenticated = False
            self.token = ''
            return True

    # Disconnection.
    def termination(self, console_id):
        # Kill a console.
        _ = self.call('console.session_kill', [console_id])
        # Log out
        _ = self.logout()
        # close error log
