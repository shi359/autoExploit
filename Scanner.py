#***********************
#*     Main Program    *
#***********************

#-----------------------
#--- Import Library ----
#-----------------------
import nmap
import json
import time
import os
import threading
from NSE_Module import *  #Costumize Module
from queue import Queue, Empty
from util import *

noHydra = ['domain','http','ldap','https','ajp13','mongodb','drda']
exploit = ['ftp','ssh','telnet','smtp','domain','http','pop3', 'netbios-ssn', 
        'microsoft-ds', 'snmp', 'imap', 'ldap', 'https', 'exec', 'login', 'ms-sql-s', 
        'oracle', 'mysql', 'postgresql', 'vnc', 'ajp13', 'mongodb', 'drda']

#---- NSE_Moudule variable ----
nseScript = NSE_Module()

class Scanner:

    def __init__(self, ips,config):

        self.dictPortScan = {}
        self.ips = ips
        self.lock = threading.Lock()
        self.timeout = int(config['nmap_timeout'])
        # record port and it's matched service of a host
        self.Port2Service = {}
        # record the services of a host that has been brutedforced
        self.bruted = {}

        if config['hydra'] == 'enable':
            self.HYDRA = True
        elif config['hydra'] == 'disable':
            self.HYDRA = False
        else:
            raise ValueError('Value of hydra should by enable/disable')

    def readFromFile(self, inputFile):
        with open(inputFile,'r') as f:
            self.dictPortScan = json.load(f)
        
        # init bruted
        for host in self.dictPortScan.keys():
            self.bruted[host] = []

        exp = self.getExploitDict()     
        self.buildPort2ServiceTable(exp) 
        return exp

    def scan(self):
        print(OKGREEN+"[*] Nmap scanning..."+ENDC)
        nm = nmap.PortScanner()
        results = nm.scan(hosts=self.ips,arguments="-sV -sC -O")
        self.buildPortScan(nm)
        exp = self.getExploitDict()
        self.buildPort2ServiceTable(exp) 
        return exp

    def getExploitDict(self):
        ans = {}
        for host, service in self.dictPortScan.items():
            ans[host] = {}
            ans[host]['os'] = service['os']
            ans[host]['service'] = []
            for serviceName, info in service['service'].items():
                ports = info['ports'].split(',')
                for p in ports:
                    tmp = {}
                    tmp['port'] = int(p)
                    sv = {}
                    sv['name'] = serviceName
                    sv['product'] = info['products']
                    tmp['info'] = sv
                    ans[host]['service'].append(tmp)
        return ans

    def buildPortScan(self,nmScan):
        # nmScan.all_hosts() will list all scanned hosts
        for host in nmScan.all_hosts():
            print(YELLOW+'----------------------------------------------------')
            print('Host : %s (%s)' % (host, nmScan[host].hostname())) 
            print('State : %s' % nmScan[host].state()) 

            if len(nmScan[host]['osmatch']) == 0:
                continue
            osInfo = self.getOS(nmScan[host])
            self.dictPortScan[host] = {}
            self.dictPortScan[host]['os'] = osInfo
            self.Port2Service[host] = {}

            self.bruted[host] = []

            # variable:proto is one of scanned hosts, value is tcp || udp
            for proto in nmScan[host].all_protocols():
                print('----------')
                print('Protocol : %s' % proto)
                # nmScan[<IP>][proto].keys() will list all keys(key are port number)
                # vaiable:lport are ports
                lport = nmScan[host][proto].keys()
                lport = sorted(lport)
                # List all port number & state(up || down) on host using for loop
                dictService = {}

                for port in lport:
                    # variable:port, type is <int>
                    print ('port : %s\tstate : %s' % (port, nmScan[host][proto][port]['state']))
                    # record Product, Name(Service Name) and version
                    strProc=nmScan[host][proto][port]['product']
                    strName=nmScan[host][proto][port]['name']
                    strVer=nmScan[host][proto][port]['version']
                    
                    if strName not in dictService:
                      dictService[strName] = {'products':strProc, 'versions':strVer, 'ports': str(port), 'scripts':{}}
                    else:
                      dictService[strName]['products'] = dictService[strName]['products'] + ';' + strProc
                      dictService[strName]['versions'] = dictService[strName]['versions'] + ';' + strVer
                      dictService[strName]['ports'] = dictService[strName]['ports'] + ',' + str(port)
            print(ENDC)
            
            self.dictPortScan[host]['service'] = dictService

    def buildPort2ServiceTable(self, exp):
        
        for host, info in exp.items():
            self.Port2Service[host] = {}
            for service in info['service']:
                port = service['port']
                name = service['info']['name']
                self.Port2Service[host].update({port:name})

    def bruteforcebyService(self, host, port):
       
        protocol = self.Port2Service[host][port]
        if protocol in self.bruted[host]:
            print("Exploited")
            return

        info = self.dictPortScan[host]['service'][protocol]
        protoName = self.getProtoName(protocol, port)

        if protocol not in exploit or protoName == '':
            print("No script for "+protocol)
            return
        
        print('%s***Start %s brute force scan***%s' %(OKGREEN, protoName, ENDC)) 
        self.lock.acquire()
        if self.HYDRA and protocol not in noHydra:
            nseScript.SMB(ip,protoName,info)
        elif protoName == 'http':
             # Using <http-auth-finder> to find authentication form
             # Function returned a list of authentication form, listPath is temporary variable to store returned value
             self.lock.acquire()
             listPath = nseScript.HTTP_Auth_Finder(ip, info)
             self.lock.release()
             # Initial dictPortScan[ip]['http']['scripts'], data type is array
             info['scripts'] = []
             # In list, format is port/path, so using '/' to split.
             # Reason of split('/', 1) is only need to split port & path. Keep other '/'symbol in path
             for path in listPath:
                 listurl = path.split('/', 1)
                 # Every list after split, send to HTTP_FORM function (IP, port, path, host_info)
                 nseScript.HTTP_FORM(ip, str(listurl[0]), '/' + str(listurl[1]), info['scripts'])
             
        elif protoName == 'smb':
            nseScript.SMB(host,protoName,info)
        else:
            nseScript.BRUTE(host,protoName,info)

        self.bruted[host].append(protocol)
        self.lock.release() 

    def writeResult(self):
        # Wrtie Scanning Result into file (JSON Format)
        with open('scan_result.json', 'w+') as outfile:  
          json.dump(self.dictPortScan, outfile)  

    def getProtoName(self,protocol, port):
        protoName = ''
        if protocol == 'domain':
            protoName = 'dns'
        elif protocol == 'netbios-ssn' or protocol == 'microsoft-ds':
            protoName = 'smb'
        elif protocol == 'https':
            protoName = 'ssl'
        elif protocol == 'exec':
            protoName = 'rexec'
        elif protocol == 'login':
            protoName = 'rlogin'
        elif protocol == 'ms-sql-s':
            protoName = 'mssql'
        elif protocol == 'postgresql':
            protoName = 'postgres'
        elif protocol == 'ajp13':
            protocol = 'ajp'
        elif port == '5000':
            protocol = 'drda'
        else:
            protoName = protocol
        
        return protoName

    def getOS(self,RawData):
        osResult = RawData['osmatch'][0]['osclass']
        platform = []
        for os in osResult:
            newos = os['osfamily'].lower()
            if newos not in platform:
                platform.append(newos)
        return platform
